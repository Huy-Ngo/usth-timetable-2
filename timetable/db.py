# Current task: rewrite this module with SQLAlchemy
# Delete this when done
from sqlalchemy import create_engine
from sqlalchemy.ext.declarative import declarative_base
from sqlalchemy import Column, Integer, String, ForeignKey
from sqlalchemy.orm import sessionmaker

from http import HTTPStatus

import json

import click
from flask import g
from flask.cli import with_appcontext

from . import request_handler as req


with open('timetable/auth/database_auth.json', 'r') as f:
	dat = json.load(f)
	username = dat['username']
	password = dat['password']

engine = create_engine(
	'mysql+mysqlconnector://'
	'{user}:{password}'
	'@{host}/{dbname}'.format(
		user=username, password=password,
		host='localhost', dbname='usth_timetable'
	),
	echo=True
)

# Declare a mapping

Base = declarative_base()


class Student(Base):
	__tablename__ = 'student'

	id = Column(Integer, primary_key=True)
	name = Column(String(32), nullable=False, unique=True)
	password = Column(String, nullable=False)
	timetable_id = Column(String, ForeignKey('timetable.id'), nullable=False)

	def __repr__(self):
		return "<Student(id = '{}', name='{}', password='{}', timetable_id='{}')>"\
			.format(self.id, self.name, self.password, self.timetable_id)


class Timetable(Base):
	__tablename__ = 'timetable'

	id = Column(Integer, primary_key=True)
	timetable_code = Column(String(5), nullable=False, unique=True)
	calendar_id = Column(String(100), nullable=False)  # the id that's generated by google

	def __repr__(self):
		return "<Timetable(id = '{}', timetable_code='{}', calendar_id='{}')>"\
			.format(self.id, self.timetable_code, self.calendar_id)


DB_TABLES = {
	'student': Student,
	'timetable': Timetable
}


Session = sessionmaker(bind=engine)


def init_db():
	Base.metadata.create_all(engine)


def close_db(e=None):
	db = g.pop('db', None)

	if db is not None:
		db.close()


# HTTP requests
def get(request_body):
	""" GET Request
	Get by id:
	request body: {
		'table_name': string
		'id': int
	}
	Get by name: {
		'table_name': string
		'name': string
	}
	info: the column in the database that is queried
	"""
	session = Session()
	if 'id' in request_body:
		data = session.query(DB_TABLES[request_body.table_name]).filter_by(id=request_body['id'])
	elif 'name' in request_body:
		data = session.query(DB_TABLES[request_body.table_name]).filter_by(name=request_body['name'])
	else:
		return req.handler(HTTPStatus.BAD_REQUEST)
	return req.handler(HTTPStatus.OK, data)


def create(table_name, request_body):
	""" Add events on update
	table_name: the name of the SQL table from which data are queried from
	request_body:
	For student:
	{
		name
		password
		timetable_id
	}
	For timetable:
	{
		timetable_code
		calendar_id
	}
	If the request body does not follows this structure,
	the function should return 400 Bad request (exception not handled).
	"""
	timetable = None
	student = None
	if table_name == 'timetable':
		if 'timetable_code' not in request_body or 'calendar_id' not in request_body:
			return req.handler(HTTPStatus.BAD_REQUEST)
		timetable = Timetable(
			timetable_code=request_body['timetable_code'],
			calendar_id=request_body['calendar_id']
		)
	elif table_name == 'student':
		if 'name' not in request_body\
				or 'password' not in request_body\
				or 'timetable_id' not in request_body:
			return req.handler(HTTPStatus.BAD_REQUEST)
		student = Student(
			name=request_body['name'],
			password=request_body['password'],
			timetable_id=request_body['timetable_id']
		)
	else:
		return req.handler(HTTPStatus.BAD_REQUEST)

	session = Session()

	if timetable is not None:
		session.add(timetable)
		return req.handler(HTTPStatus.CREATED, timetable)
	elif student is not None:
		session.add(student)
		return req.handler(HTTPStatus.CREATED, student)
	else:
		return req.handler(HTTPStatus.BAD_REQUEST, request_body)


def update(table_name, item_id, request_body):
	"""
	request_body: {
		any valid information that can be changed
	}
	"""
	session = Session()

	if 'id' in request_body:
		return req.handler(HTTPStatus.BAD_REQUEST)
	session.query(DB_TABLES[table_name]).filter_by(id=item_id).update(request_body)

	ret_obj = session.query(DB_TABLES[table_name]).filter_by(id=item_id).first()
	if ret_obj is None:
		return req.handler(HTTPStatus.NOT_FOUND)
	return req.handler(HTTPStatus.OK, ret_obj)


def delete(table_name, item_id):
	session = Session()
	session.query(DB_TABLES[table_name]).filter_by(id=item_id).delete()
	# I'm not sure if this works. Please check and confirm.


@click.command('init-db')
@with_appcontext
def init_db_command():
	"""Clear the existing data and create new tables"""
	init_db()
	click.echo('Initialized the database.')


def init_app(app):
	app.teardown_appcontext(close_db)
	app.cli.add_command(init_db_command)
